from dataclasses import dataclass
from typing import Any, Iterable

from rules.basic import Card
from rules.game_flow import PokerGame, GameEvent


"""
Attributes to be synced
"""

GAME_SYNC_ATTRS = {
    GameEvent.NEW_HAND:      ["players", "dealer", "sb_amount"],
    GameEvent.NEW_ROUND:     ["players", "hand"],
    GameEvent.SKIP_ROUND:    ["players", "hand"],
    GameEvent.SHOWDOWN:      ["players", "hand"],
    GameEvent.RESET_PLAYERS: ["players"],
    GameEvent.JOIN_MID_GAME: ["players", "hand", "dealer", "sb_amount"],
}
# `PokerGame` attributes to sync according to the type of game event.

HAND_SYNC_ATTRS = ["players", "winners", "pots", "community_cards", "current_round_bets"]  # `Hand` attributes to sync.
PLAYER_SYNC_ATTRS = ["name", "chips", "player_number"]  # `Player` attributes to sync.

PLAYER_HAND_SYNC_ATTRS = ["pot_eligibility", "folded", "all_in"]  # `PlayerHand` attributes to sync.
PLAYER_HAND_SYNC_ATTRS_SD = ["pocket_cards", "hand_ranking", "winnings", "pots_won"]  # Extra `PlayerHand` attributes to sync on showdowns.
PLAYER_HAND_SYNC_ATTRS_MG = ["current_round_spent", "last_action"] # Extra `PlayerHand` attributes to sync on "join mid-game" events.


@dataclass
class GameData:
    """
    The `GameData` dataclass is used to sync the client-sided `MultiplayerGame` with the server-sided `ServerGameRoom`.
    """
    attr_dict: dict[str, Any]

    # Extra stuff (non-PokerGame attributes)
    client_player_number: int = -1
    client_pocket_cards: list[Card] = None


def dump_select_attrs(o: object, attr_list: list[str], exclude: Iterable[str] = ()) -> dict[str, Any]:
    """
    Creates a dict that contains some of the attributes of the given object. Similar to the __dict__ attribute or vars()
    function, but this time it only includes the attributes specified in `attr_list` and not specified in `exclude`.

    :param o: The object to be dumped.
    :param attr_list: Attributes of the object to be dumped into the dict.
    :param exclude: Attributes in attr_list to be excluded from the dict.
    :return: A dict containing the attributes of the object.
    """
    return {attr: getattr(o, attr) for attr in attr_list if attr not in exclude}


def load_attrs(o: object, attr_dict: dict[str, Any], exclude: Iterable[str] = ()) -> None:
    """
    Set the attributes of an object to the values contained in a given attribute dict generated by `dump_select_attrs`.

    :param o: The object to be loaded.
    :param attr_dict: The attribute dict.
    :param exclude: Attributes in attr_list to not be loaded.
    """
    for attr, value in attr_dict.items():
        if attr not in exclude:
            setattr(o, attr, value)


def dump_game_sync_data(game: PokerGame, game_event_code) -> GameData:
    """
    Creates a GameData object to be sent to the clients in order for them to sync their game data. The attributes
    included in the game data object is largely based on the type of game event.

    :param game: The PokerGame object.
    :param game_event_code: The game event code representing the type of event.
    :return: The GameData object containing the attribute dict and additional stuff.
    """
    if game_event_code not in GAME_SYNC_ATTRS:
        return GameData({})

    attr_list = GAME_SYNC_ATTRS[game_event_code]
    attr_dict = dump_select_attrs(game, attr_list, ["players", "hand"])

    if "players" in attr_list:
        attr_dict["players"] = [dump_select_attrs(player, PLAYER_SYNC_ATTRS) for player in game.players]

    if "hand" in attr_list:
        attr_dict["hand"] = dump_select_attrs(game.hand, HAND_SYNC_ATTRS, ["players"])

        phand_sync_attrs = PLAYER_HAND_SYNC_ATTRS
        if game_event_code == GameEvent.SHOWDOWN:
            phand_sync_attrs += PLAYER_HAND_SYNC_ATTRS_SD
        elif game_event_code == GameEvent.JOIN_MID_GAME:
            phand_sync_attrs += PLAYER_HAND_SYNC_ATTRS_MG

        attr_dict["hand"]["players"] = [dump_select_attrs(player, phand_sync_attrs) for player in game.hand.players]

    return GameData(attr_dict)
